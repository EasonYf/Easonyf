import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as e,d as a}from"./app-55302f36.js";const r={},o=a('<h2 id="浏览器的渲染过程" tabindex="-1"><a class="header-anchor" href="#浏览器的渲染过程" aria-hidden="true">#</a> 浏览器的渲染过程</h2><p>浏览器获得html、css、js等，将代码渲染到页面的过程如下：</p><ol><li>解析HTML、生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树（Render Tree）</li></ol><p><img src="https://eason-blog.oss-cn-chengdu.aliyuncs.com/blogPicture/202401142149846.png" alt="image.png" loading="lazy"> 图1.DOM、CSSOM、Render Tree</p><ol start="3"><li>根据生成的渲染树，进行回流，获得节点的几何信息（包括位置、大小）</li><li>根据渲染树和回流获得的节点几何信息将其具体化，将位置、大小转换成绝对像素交给GPU</li><li>GPU获得节点的像素，通过GPU图像处理单元处理后展示到页面上</li></ol><h2 id="生成渲染树" tabindex="-1"><a class="header-anchor" href="#生成渲染树" aria-hidden="true">#</a> 生成渲染树</h2><p>总所周知，浏览器会通过网络进程获取到需要的HTML等文档资源，然后交给浏览器渲染进程，在浏览器渲染进程中会开始解析HTML，解析CSS，同时生成了Render Tree，构建渲染树的过程如下：</p><ol><li>通过DOM树从根节点开始遍历每个可见节点</li><li>对于每一个可见节点，对照CSSOM树找到对应的规则，应用</li><li>根据每个可见节点和样式生成渲染树</li></ol><p>不可见节点包括：</p><ul><li>设置<code>display:none</code></li><li>输出节点，<code>script、meta、link</code>等</li></ul><p>注意：css设置<code>visibility</code>和<code>opacity</code>隐藏节点，虽然页面不可见，但是同样会解析到渲染树上。</p><h2 id="回流-reflow" tabindex="-1"><a class="header-anchor" href="#回流-reflow" aria-hidden="true">#</a> 回流（Reflow）</h2><ul><li>回流是指浏览器为了重新渲染部分或者全部文档而重新结算元素的位置和几何大小的过程</li><li>触发条件： <ul><li>当改变元素的位置或者几何大小时 <ul><li>删除或添加DOM元素</li><li>元素的位置发生改变</li><li>元素的尺寸发生改变（包括外边距、内边距、边框大小、高度和宽度等）</li><li>内容发生变化、比如文本改变，图片被不同尺寸的图片替换等</li><li>页面首次渲染的时候</li><li>浏览器窗口大小发生变化</li></ul></li></ul></li><li>影响：回流是来计算元素的位置和几何大小的，是一种昂贵的操作，它会影响整个页面的布局，所有是很影响性能的，所以我们要减少回流，提高性能</li></ul><h2 id="重绘-repaint" tabindex="-1"><a class="header-anchor" href="#重绘-repaint" aria-hidden="true">#</a> 重绘（Repaint）</h2><ul><li>重绘是指根据浏览器的样式重新绘制元素的过程，又是知道节点的位置和几何大小后转换成绝对像素的过程</li><li>触发条件 <ul><li>回流一定触发重绘</li><li>当元素的可见样式（例如颜色、背景、阴影等）发生改变时，可能触发重绘。</li></ul></li></ul>',15),c=[o];function t(d,n){return i(),e("div",null,c)}const _=l(r,[["render",t],["__file","浏览器：重绘与回流.html.vue"]]);export{_ as default};
